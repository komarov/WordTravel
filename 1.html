<html>
<body>
<script type="text/javascript" src="raphael-min.js"></script>

<script type="text/javascript">

var DEBUG = true;

Object.prototype.map = function( mapFunction ) {

   var result = {};

   for( var property in this ) {
      if( this.hasOwnProperty( property ) ) {
         result[ property ] = mapFunction( this[ property ] );
      }
   }

   return result;
};

Raphael.el.getHotSpot = function() {
   var bbox = this.getBBox();
   return { 
      x: bbox.x + bbox.width / 2, 
      y: bbox.y + bbox.height / 2
   };
};

function getFrame() {

   var frame = {
      'Links': [
         [
            '8EC0B16E-E7EB-11DE-B3BD-C724A05985A0',
            '8EC99946-E7EB-11DE-B3BD-C724A05985A0'
         ],
         [
            '8EC99946-E7EB-11DE-B3BD-C724A05985A0',
            '8ED02950-E7EB-11DE-B3BD-C724A05985A0'
         ],
         [
            '8ED02950-E7EB-11DE-B3BD-C724A05985A0',
            '8ED9AF20-E7EB-11DE-B3BD-C724A05985A0'
         ],
         [
            '8ED02950-E7EB-11DE-B3BD-C724A05985A0',
            '8EDA547A-E7EB-11DE-B3BD-C724A05985A0'
         ]
      ],
      'Words': {
         '8EC0B16E-E7EB-11DE-B3BD-C724A05985A0': 'aBc',
         '8ED9AF20-E7EB-11DE-B3BD-C724A05985A0': 'secretskdlgksjdklgjhsdklgjdhslkdh',
         '8ED02950-E7EB-11DE-B3BD-C724A05985A0': 'real',
         '8EC99946-E7EB-11DE-B3BD-C724A05985A0': '123',
         '8EDA547A-E7EB-11DE-B3BD-C724A05985A0': '.......'
      },
      'Hidden': {
         '8EC0B16E-E7EB-11DE-B3BD-C724A05985A0': true,
         '8ED9AF20-E7EB-11DE-B3BD-C724A05985A0': false,
         '8ED02950-E7EB-11DE-B3BD-C724A05985A0': true,
         '8EC99946-E7EB-11DE-B3BD-C724A05985A0': false,
         '8EDA547A-E7EB-11DE-B3BD-C724A05985A0': true
      }
   };

   return frame;
}

function NewWordCell( paper, x, y, text, links, hidden ) {
   return {
      'Text': paper.text( x, y, text ).hide(),
      'Cell': paper.rect( x, y ).hide(),
      'Links': links,
      'Hidden': hidden
   }
}

function parseWordCells( frame, paper ) {
   
   var wordCells = {};

   for( var wordUID in frame.Words ) {
      if( frame.Words.hasOwnProperty( wordUID ) ) {
         wordCells[ wordUID ] = NewWordCell( paper, 0, 0, frame.Words[ wordUID ], getLinks( frame, wordUID ), true );
         if( DEBUG ) console.log( wordCells[ wordUID ] );
      }
   }

//   if( DEBUG ) console.log( wordCells );
   return wordCells;
}

function getLinks( frame, UID ) {

   var links = [];
   
   for( var index in frame.Links ) {
      if( frame.Links.hasOwnProperty( index ) ) {
         var link = frame.Links[ index ];
         if( UID == link[ 0 ]  ) {
            links.push( link[ 1 ] );
         }
         if( UID == link[ 1 ] ) {
            links.push( link[ 0 ] );
         }
      }
   }

   return links;
}

function drawWordCells( paper, wordCells ) {

   if( DEBUG ) console.log( wordCells );

   var cells = wordCells.map( function( wordCell ) { return wordCell.Cell } );
   for( var wordUID in wordCells ) {
      if( wordCells.hasOwnProperty( wordUID ) ) {

         if( DEBUG ) console.log( wordCells[ wordUID ] );         
         var word = "";
         var x = y = 0;

         var rect = wordCells[ wordUID ].Cell;
         var txt = wordCells[ wordUID ].Text;


         txt.attr( { fill: "#fff", font: "18px \"Terminal\"" } );
         var edgeDelta_x = txt.getBBox().width;
         var edgeDelta_y = txt.getBBox().height;

         while( !isFree( cells, x, y ) ) { 
            x = edgeDelta_x + Math.random() * ( paper.width - 2 * edgeDelta_x );
            y = edgeDelta_y + Math.random() * ( paper.height - 2 * edgeDelta_y );

            if( DEBUG ) console.log( x, y );
         }


         if( DEBUG ) console.log( x, y );
         txt.attr( {x: x, y: y} );
         rect.attr( { x: x - edgeDelta_x / 2 - 5, y: y - edgeDelta_y / 2, fill: "#000", stroke: "#0f0", width: edgeDelta_x + 10, height: edgeDelta_y + 6, r: 3 } );
         rect.show();
         rect.toBack();

         txt.show();
      }
   }
}

function drawLinks( paper, wordCells, frame ) {

   var cells = wordCells.map( function( wordCell ) { return wordCell.Cell } );
   for( var index in frame.Links ) {
      if( frame.Links.hasOwnProperty( index ) ) {
         var link = frame.Links[ index ]; 
         if( DEBUG ) console.log( cells[ link[ 0 ] ] );
         var hotSpot_0 =  cells[ link[ 0 ] ].getHotSpot();
         var hotSpot_1 =  cells[ link[ 1 ] ].getHotSpot();

         var path = paper.path( "M" + hotSpot_0.x + " " + hotSpot_0.y + "L" + hotSpot_1.x + " " + hotSpot_1.y ).attr( 'stroke', '#0f0' );
         path.toBack();
         

      }
   }
  
}


function drawWord( paper, word, x, y, round ) {

   var text = paper.text( x, y, word ).attr( { fill: "#fff", font: "18px \"Terminal\"" } );
   text.hide();
   if( DEBUG ) console.log( text.node );
   text.node.onclick = function () { text.attr( { fill: "black" } ) };
  
   var textBB = text.getBBox();
   var rect = paper.rect( textBB.x, textBB.y, textBB.width + 4 * round, textBB.height + 2 * round, round ).attr( { fill: "#000", stroke: "#0f0" } );
   rect.hide();
   if( DEBUG ) console.log( rect.node );
   rect.node.onclick = function () { rect.attr( { fill: "white" } ) };


   return { 'rectangle': rect, 'txt': text };
}

function isFree( places, x, y ) {

   if( x == 0 && y == 0 ) {
      return false;
   }
   for( var place in places ) {
      if( places.hasOwnProperty( place ) ) {
         var occupied = places[ place ].getBBox(); 
         if( ( x <= occupied.x + occupied.width + 10  && x >= occupied.x - 10 ) || ( y <= occupied.y + occupied.height + 10 && y >= occupied.y - 10 ) ) {
            return false;
         }
      }
   }
   
   return true;

}

function stickToEdges( x, y, width, height, h ) {

   if( x < h || y < h || x > width - h || y > height - h ) {
      return true;
   }
   
   return false;
   
}

window.onload = function() { 

   var paperWidth = 800;
   var paperHeight = 600;
   var centerX =  window.innerWidth / 2;
   var centerY =  window.innerHeight / 2;
   var startX = centerX - paperWidth / 2;
   var startY = centerY - paperHeight / 2;

   var paper = new Raphael( document.getElementById('raphael_canvas'), paperWidth, paperHeight );

   var newFrame = getFrame();
   var wordCells = parseWordCells( newFrame, paper );
   drawWordCells( paper, wordCells );
   drawLinks( paper, wordCells, newFrame );

   if( DEBUG ) console.log( wordCells );

}


</script>

<div id="raphael_canvas" align="center" style="background-color:black;width:800px" ></div>

</body>
</html>
